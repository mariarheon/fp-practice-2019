module Task4_1 where

{-
  Задание 4.1
  Реализация монады над функцией.
  Реализуйте все требуемые классы типов и объясните, почему они реализованы именно так.
-}

-- Монада над функцией. В качестве входного значения `fun` может быть что угодно
-- Собственно, почему бы не `String`?
data FunMonad a = FunMonad { fun :: String -> a }

-- реализуйте классы `Functor`, `Applicative` и `Monad` для типа `FunMonad`

-- Functor преобразовывает элементы одного множества в элементы другого
-- собственно, fmap применяет функцию ко всем элементам множества
-- в нашем случае применим преобразование f к результату (String -> a) 
instance Functor FunMonad where
    fmap f (FunMonad fm) = FunMonad(\x -> f (fm x)) 

-- Applicative оборачивает в контекст не только аргумент, но и функцию, которая к нему применяется 
instance Applicative FunMonad where
-- pure помещает значения в контекст
-- независимо от аргумента, результатом будет являться FunMonad
    pure fm = FunMonad(\x -> fm)

-- <*> применяет функцию, помещенную в контекстfm1 к значению, помещенному в контекст fm2
-- по логике будем сначала доставать оба этих параметра из контекста и применять полученную функцию
-- к значению
    (<*>) (FunMonad fm1) (FunMonad fm2) = FunMonad(\x -> (fm1 x) $ (fm2 x))

-- Monad позволяет описать способ комбинирования вычислений и результатов
instance Monad FunMonad where
-- return упаковывает значение в монаду
    return fm = FunMonad(\x -> fm)
-- >>= описывает применение функции f, которая возращает значение, обернутое в контекст к
-- значению, обернутом в контекст fm. Для этого выполним следюущее:
-- достаем из контекста значение (fm x), применяем функцию f. 
-- Далее получаем функциюю fun, к которой применяется аргумент х.
    (>>=) (FunMonad fm) f = FunMonad(\x -> fun (f (fm x)) x)
